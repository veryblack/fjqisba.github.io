[{"categories":["爬虫"],"content":"对CEF程序进行爬虫 想标题想了很久，最后感觉还是用这个标题比较合适。 问题情景是这样的： 有一个较为古老的CEF程序，需要对程序里面的内容进行爬取，获取数据。 众所周知，CEF框架无非就是个浏览器，最终访问的还是网页，那么我们直接访问网页进行爬取不就好了吗? 但实际上能否这样做是值得商榷的，例如我要爬取的那个程序，通过CEF注册JS扩展的方式，使网页与本地的其它进程建立起了通讯，这样我就不能脱离这个CEF程序而独立去访问网页了，否则页面将无法正常运作。 遇到这种情况，我们可以根据远程调试协议开启浏览器的远程调试功能，再用Selenium或者Puppeteer等爬虫工具挂接浏览器，这样我们就可以对浏览器进行一些自动化操作了。 ","date":"2020-09-20","objectID":"/posts/%E5%AF%B9cef%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB/:0:0","tags":["浏览器","CEF","Selenium"],"title":"对CEF程序进行爬虫","uri":"/posts/%E5%AF%B9cef%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB/"},{"categories":["爬虫"],"content":"开启远程调试 开启方法很简单，在要调试的浏览器进程快捷方式属性上加上参数: --remote-debugging-port=9222 --user-data-dir=C:\\ChromeDebug\r远程调试端口一般为9222，用户数据目录我们随便创建一个就好。 这个时候我们可以访问127.0.0.1:9222/json/version，其中有一个值叫webSocketDebuggerUrl，调试程序主要就是根据这个URL来连接上浏览器的。 ","date":"2020-09-20","objectID":"/posts/%E5%AF%B9cef%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB/:0:1","tags":["浏览器","CEF","Selenium"],"title":"对CEF程序进行爬虫","uri":"/posts/%E5%AF%B9cef%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB/"},{"categories":["爬虫"],"content":"Selenium爬虫 为什么使用Selenium而不是Puppeteer呢？先前已经提到，该CEF程序是一个古老的程序，Chromium浏览器内核版本为V58左右，而Puppeteer框架对浏览器版本有着严格的限制，官方也有说明:每一个版本的Puppeteer理论上只适配一个特定版本的Chromium浏览器。而Selenium框架对版本支持更加友好，不管老版本还是新版本，都有适配的浏览器驱动，我们只需要去下载相应版本的WebDriver.exe即可。下载地址如下: http://chromedriver.storage.googleapis.com/index.html 至于Selenium的使用教程，参考一下: https://selenium-python-zh.readthedocs.io/en/latest/ 编写代码连接上浏览器 from selenium import webdriver chrome_options = webdriver.ChromeOptions() chrome_options.add_experimental_option('debuggerAddress','127.0.0.1:9222') browser = webdriver.Chrome(executable_path=\"C:\\chromedriver.exe\",chrome_options=chrome_options) browser.get('http://www.baidu.com') 之后后面的模拟点击、爬取内容就不再细谈了。 ","date":"2020-09-20","objectID":"/posts/%E5%AF%B9cef%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB/:0:2","tags":["浏览器","CEF","Selenium"],"title":"对CEF程序进行爬虫","uri":"/posts/%E5%AF%B9cef%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB/"},{"categories":["杂文"],"content":"DocFx学习笔记 1.DocFx是微软的一款开源的文档生成工具，下载地址如下:https://github.com/dotnet/docfx/releases 软件的官网是https://dotnet.github.io/docfx，在里面还可以获取到一些教程 2.此软件的运行需要.Net Framework 4.7.2环境，需要自行安装 3.创建一个DocFx工程 docfx init -q\r4.建立网站 docfx docfx_project\\docfx.json --serve\r这样就可以通过访问http://localhost:8080来查看文档页面了，里面包含了一些基本的页面。 ","date":"2020-09-13","objectID":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["笔记","DocFx"],"title":"DocFx学习笔记","uri":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["杂文"],"content":"docfx.json解析 docfx.json是docfx用于生成文档的配置文件，目前docfx.json只包含了两个键值对，分别是metadata和build。 metadata属性如下(暂时对我来说好像没什么用，我就不管了): Key Description src 工程源码的位置 dest 存放生成的metadata文件的目录 force shouldSkipMarkup filter useCompatibilityFileName properties build属性如下: Key Description content 用于生成文档的全部文件 resources 资源文件或者元数据文件，例如图片文件。 overwrite Contains all the conceptual files which contains yaml header with uid and is intended to override the existing metadata yml files. name-files file mapping with several ways to define it, as to be described in Section4. globalMetadata 应用于每个文件的配置选项，例如在globalMetadata中定义\"_appTitle\": \"我是标题\",则每个页面都会追加标题文本。 fileMetadata Contains metadata that will be applied to specific files. name-files file mapping with several ways to define it, as to be described in Section4. globalMetadataFiles Specify a list of JSON file path containing globalMetadata settings, as similar to {\"key\":\"value\"}. Please read Section3.2.3 for detail. fileMetadataFiles Specify a list of JSON file path containing fileMetadata settings, as similar to {\"key\":\"value\"}. Please read Section3.2.3 for detail. template The templates applied to each file in the documentation. It can be a string or an array. The latter ones will override the former ones if the name of the file inside the template collides. If omitted, embedded default template will be used. theme The themes applied to the documentation. Theme is used to customize the styles generated by template. It can be a string or an array. The latter ones will override the former ones if the name of the file inside the template collides. If omitted, no theme will be applied, the default theme inside the template will be used. xref Specifies the urls of xrefmap used by content files. Currently, it supports following scheme: http, https, ftp, file, embedded. xrefService Specifies the url patterns of xref service. Please read Section3.2.4 for detail. exportRawModel If set to true, data model to run template script will be extracted in .raw.json extension. rawModelOutputFolder Specify the output folder for the raw model. If not set, the raw model will be generated to the same folder as the output documentation. exportViewModel If set to true, data model to apply template will be extracted in .view.json extension. viewModelOutputFolder Specify the output folder for the view model. If not set, the view model will be generated to the same folder as the output documentation. dryRun If set to true, template will not be actually applied to the documents. This option is always used with --exportRawModel or --exportViewModel, so that only raw model files or view model files are generated. maxParallelism Set the max parallelism, 0 (default) is same as the count of CPU cores. markdownEngineName Set the name of markdown engine, default is dfm, other available engines are gfm and markdig. markdownEngineProperties Set the parameters for markdown engine, value should be a JSON string. noLangKeyword Disable default lang keyword, it can be downloaded from here. keepFileLink If set to true, docfx does not dereference (aka. copy) file to the output folder, instead, it saves a link_to_path property inside manifest.json to indicate the physical location of that file. A file link will be created by incremental build and copy resouce file. sitemap In format SitemapOptions Specifies the options for the sitemap.xml file. disableGitFeatures Disable fetching Git related information for articles. Set to true if fetching git related information is slow for huge Git repositories. Default value is false. ","date":"2020-09-13","objectID":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["笔记","DocFx"],"title":"DocFx学习笔记","uri":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["杂文"],"content":"更换主题模板 我个人对官方默认的主题不是特别满意，我们可以去官网下载其它的主题模板。 下载完成后进行以下步骤使用模板 在Doxfx网站根目录创建一个templates文件夹 将主题文件夹拷贝至templates文件夹目录下 在docfx.json中的template项中添加模板文件夹的路径，例如我使用的是mathew主题模板 { \"template\": [ \"default\", \"templates/mathew\" ], } 主题文件夹中有一个main.css可以用来修改主题的一些属性 ","date":"2020-09-13","objectID":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["笔记","DocFx"],"title":"DocFx学习笔记","uri":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["杂文"],"content":"配置文档目录 docfx工程默认结构如下: docfx_project/index.md为主页的显示内容 docfx_project/toc.yml为文档目录配置文件，对应docfx_project/api和docfx_project/articles这两个目录 我们可以通过修改docfx_project/toc.yml来配置文档目录，例如默认配置文件如下 - name:Articleshref:articles/- name:ApiDocumentationhref:api/homepage:api/index.mdyml这种数据格式可能不太熟悉，其实和json差不多，转换成json如下 [ { \"name\": \"Articles\", \"href\": \"articles/\" }, { \"name\": \"Api Documentation\", \"href\": \"api/\", \"homepage\": \"api/index.md\" } ] 在添加目录或者修改目录的时候，同时也要修改docfx_project/docfx.json中的content，因为content包含用于生成文档的全部文件。 ","date":"2020-09-13","objectID":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["笔记","DocFx"],"title":"DocFx学习笔记","uri":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["杂文"],"content":"开启搜索功能 如果想要开启程序自带的搜索功能，需要进行以下两步: 程序其实预留了一些配置项，通过修改globalMetadata可以设置它们，在docfx_project/docfx.json中添加以下globalMetadata项 \"globalMetadata\": { \"_enableSearch\": \"true\", }, 这样我们就开启了页面上的搜索栏。 程序如果要对生成后的HTML文件继续处理，可以通过添加postProcessors项来进行操作，在docfx_project/docfx.json中添加postProcessors项 \"postProcessors\": [ \"ExtractSearchIndex\" ], 这表示程序会在生成HTML文件之后提取里面的单词生成一个数据库，可用于搜索。 程序完整的预留MetaData如下: Metadata名称 类型 描述 _appTitle string Will be appended to each output page’s head title. _appFooter string 页脚内容，如果未设置则默认为Generated by DocFX _appLogoPath string Logo file’s path from output root. Will show DocFX’s logo if not specified. Remember to add file to resource. _appFaviconPath string Favicon file’s path from output root. Will show DocFX’s favicon if not specified. Remember to add file to resource. _enableSearch bool 用于设置是否在页面上方显示搜索栏 _enableNewTab bool Indicate whether to open a new tab when clicking an external link. (internal link always shows within the current tab) _disableNavbar bool Indicate whether to show the navigation bar on the top of page. _disableBreadcrumb bool Indicate whether to show breadcrumb on the top of page. _disableToc bool Indicate whether to show table of contents on the left of page. _disableAffix bool Indicate whether to show the affix bar on the right of page. _disableContribution bool Indicate whether to show the View Source and Improve this Doc buttons. _gitContribute object Customize the Improve this Doc URL button for public contributors. Use repo to specify the contribution repository URL. Use branch to specify the contribution branch. Use apiSpecFolder to specify the folder for new overwrite files. If not set, the git URL and branch of the current git repository will be used. _gitUrlPattern string Choose the URL pattern of the generated link for View Source and Improve this Doc. Supports github and vso currently. If not set, DocFX will try speculating the pattern from domain name of the git URL. _noindex bool File(s) specified are not returned in search results ","date":"2020-09-13","objectID":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["笔记","DocFx"],"title":"DocFx学习笔记","uri":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["心情文学"],"content":"以下是个人对于创业的一点小小的思考。 作为一名创业者，思路应该是这样的: 深入挖掘社会的潜在需求 -\u003e 根据需求来设计项目 -\u003e 评估项目可行性(资金、人员、周期) -\u003e 组织人员推动项目进展 ","date":"2020-09-13","objectID":"/posts/%E7%A4%BE%E4%BC%9A%E9%9C%80%E6%B1%82%E4%B8%8E%E5%88%9B%E4%B8%9A/:0:0","tags":["创业","社会需求"],"title":"社会需求与创业","uri":"/posts/%E7%A4%BE%E4%BC%9A%E9%9C%80%E6%B1%82%E4%B8%8E%E5%88%9B%E4%B8%9A/"},{"categories":["心情文学"],"content":"社会的潜在需求: 为什么要说是潜在需求呢？因为明面上的需求大家都看得见，要么是已经被人解决了，要么是解决不了遗留着的。只有找到社会的潜在需求才能创造价值、创造财富。 就目前来说我个人能想到的需求有: 远程办公需求:未来某些职业(互联网相关?)在条件上是可以实施云办公的吧。如果能够在家中工作，我想员工的幸福度也许会大幅度提升，而且远程办公一旦能够落地实施，终将会成为一种趋势。但是目前的情况是软硬件环境跟不上，目前仍需要一套成熟的远程办公的解决方案。需要5G + 全息投影 + 软件 + 办公规则的制定。 ","date":"2020-09-13","objectID":"/posts/%E7%A4%BE%E4%BC%9A%E9%9C%80%E6%B1%82%E4%B8%8E%E5%88%9B%E4%B8%9A/:0:1","tags":["创业","社会需求"],"title":"社会需求与创业","uri":"/posts/%E7%A4%BE%E4%BC%9A%E9%9C%80%E6%B1%82%E4%B8%8E%E5%88%9B%E4%B8%9A/"},{"categories":["逆向生涯"],"content":"IE TAB浏览器扩展插件修改过程 事情是这样的，我在使用Puppeteer框架对网站进行爬取的时候，发现有些页面使用到了ActiveX控件。众所周知，只有IE浏览器才支持ActiveX控件，而Puppeteer却不支持IE浏览器！这导致我在爬取的过程中页面无法正常加载，这样一来我也就截取不到我想要的一些请求了。 在尝试解决该问题的过程我了解到了IE TAB，IE Tab 是网页浏览器的一个扩展插件，支持Firefox/Chrome。 IE TAB应用场景: 有些网站页面格式不标准，或者使用到了ActiveX控件，只能在IE浏览器中正常显示。而这个时候我们又想在Chrome/FireFox浏览器中访问此网站，这个时候就可以使用IE TAB插件，此插件主要功能是通过调用Internet Explorer的引擎来访问网页，解决一些网页无法在当前标准的浏览器中正常显示的问题。 该软件安装使用可能要用到科学上网，软件分免费版和授权版两种。 免费版能满足普通用户的大部分使用需求，但是对选项进行设置需要进行联网。 授权版有着GPO组策略部署等更方便好用的功能(不知道是啥玩意。。。)。 于是我便打算对IE TAB进行个人修改(去除一些我不想要的功能，添加我想要的功能)。 ","date":"2020-09-07","objectID":"/posts/ie-tab%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/:0:0","tags":["浏览器扩展","绿化"],"title":"IE TAB浏览器扩展插件修改过程","uri":"/posts/ie-tab%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"},{"categories":["逆向生涯"],"content":"知识点归纳 1.程序ietabhelper.exe会释放一个文件ietab_nm_manifest.json至目录C:\\Users\\fjqisba\\AppData\\Local\\IE Tab下，同时在注册表SOFTWARE\\Google\\Chrome\\NativeMessagingHosts\\net.ietab.ietabhelper.peruser中写入该json文件路径。这样的目的其实是为了注册本地消息主机。 本地消息主机(Native messaging): 通过将浏览器所在客户端的本地应用注册为本地消息主机，Chrome浏览器扩展可以和本地应用之间收发消息。 本地应用要想成为\"本地消息主机”，必须有一个有效的json配置文件，例如: { \"name\": \"com.my_company.my_application\", \"description\": \"My Application\", \"path\": \"C:\\\\MyApplication.exe\", \"type\": \"stdio\", \"allowed_origins\": [ \"chrome-extension://ndbehkpfbjcaflobmibchkjiphgibnid/\" ] } 其中path为本地应用的执行路径；allowed_origins为授权能够与本地消息主机进行通讯的浏览器扩展，不得有通配符。 之后在安装本地应用时需要在注册表中指明配置文件的路径，例如创建key HKEY_CURRENT_USER\\SOFTWARE\\Google\\Chrome\\NativeMessagingHosts\\com.my_company.my_application 设置默认值Default为配置文件所在的绝对路径。 程序注册了本地消息主机，是为了让浏览器扩展和程序自带的ietabhelper.exe进行通讯，个人推测一些核心功能其实是在ietabhelper.exe中，例如调用IE浏览器引擎等。 很明显我们在重新打包扩展插件的时候，浏览器扩展插件的id会发生变化，因此我们需要修改配置文件中allowed_origins的内容，allowed_origins内容其实来源于ietabhelper.exe中，我们可以对该exe进行patch，加入我们自己的浏览器扩展插件id。 2.在nathost_manager.js中似乎对浏览器扩展ID还有判断，先不管对不对，加上自己的ID就完事了。 _updateAllowedOrigins: function(manifestContent) { // hehijbfgiekmjfkfjpbkbammjbdenadd - Chrome Web Store release // knnoopddfdgdabjanjmeodpkmlhapkkl - IE Tab Enterprise edition // ncdgipmkgkhennagnfmnlkflidilhbdi - IE Tab Enterprise self-deployed // npjkkakdacjaihjaoeliacmecofghagh - Windows Store for Edge // almljgkjodjgoldenkijomojnejpkcjk - IE Tab Beta for Chrome var origins = [ 'chrome-extension://hehijbfgiekmjfkfjpbkbammjbdenadd/', 'chrome-extension://knnoopddfdgdabjanjmeodpkmlhapkkl/', 'chrome-extension://ncdgipmkgkhennagnfmnlkflidilhbdi/', 'chrome-extension://npjkkakdacjaihjaoeliacmecofghagh/', 'chrome-extension://almljgkjodjgoldenkijomojnejpkcjk/' ]; var me = chrome.extension.getURL(''); if ( (origins[0] != me) \u0026\u0026 (origins[1] != me)) { origins.push(me); } var cleanOrigins = JSON.stringify(origins); cleanOrigins = cleanOrigins.replace(/[\\[\\]]/g, ''); return manifestContent.replace('ALLOWED_ORIGINS', cleanOrigins); }, 3.在进行选项设置的时候，你需要访问http://www.ietab.net/options这个网址才行，其实就软件功能来说，理应可以实现完全本地化的，但是作者非要你访问他的官网，这里我们直接将options.html给离线存储下来，相应的服务器js、html、css也保存到本地，再修正一下HTML引用的文件URL。 之后我们还需要修改一下程序的配置，在manifest.json中有一个值为content_scripts，简要介绍如下: Content scripts是在Web页面内运行的javascript脚本。通过使用标准的DOM，它们可以获取浏览器所访问页面的详细信息，并可以修改这些信息。 下面是content scipt可以做的一些事情范例： 从页面中找到没有写成超链接形式的url，并将它们转成超链接。 放大页面字体使文字更清晰 找到并处理DOM中的microformat 当然，content scripts也有一些限制，它们不能做的事情包括 ： 不能使用除了chrome.extension之外的chrome.* 的接口 不能访问它所在扩展中定义的函数和变量 不能访问web页面或其它content script中定义的函数和变量 不能做cross-site XMLHttpRequests 这些限制其实并不像看上去那么糟糕。Content scripts 可以使用messages机制与它所在的扩展通信，来间接使用chrome.*接口，或访问扩展数据。Content scripts还可以通过共享的DOM来与web页面通信。 总之，可以理解为一个页面注入js，而IE TAB存在这么一个配置 content_scripts\": [ { \"js\": [ \"js/extapi_cs.js\" ], \"matches\": [ \"*://*.ietab.net/*\" ], \"run_at\": \"document_start\" } ] 意思就是，程序在访问http://www.ietab.net/options这个网址时，便会注入extapi_cs.js这个js，这个js非常关键，涉及到核心功能之间的相互通讯，如果没有的话那么功能会无法执行起来。由于我们本地化了options.html，因此我们也需要注入这个js，其实方式也很简单，我们可以直接在options.html中加入下列代码 \u003cscript src=\"js/extapi_cs.js\"\u003e\u003c/script\u003e 这样便完成了和原程序一样的注入。 4.软件使用到了localStorage来存储配置选项信息+授权信息，在Settings.js中存在以下代码，为程序加载的一些默认项 localStorage为浏览器的本地存储机制，存储时间理论上来说是永久有效的，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。 DEFAULT_SETTINGS: {\r'compat-mode': 'IE7S',\r'disable-intro-page': false,\r'enable-auto-urls': true,\r'enable-chrome-popups': true,\r'settings-refresh-interval': 1000*60*10, // Every 10 minutes\r'show-search-box': false,\r'enable-use-full-window-popups': true,\r'enable-dep': true,\r'enable-atl-dep': true,\r'only-auto-urls' : false,\r'hide-addr-bar' : false,\r'show-status-text' : false,\r'open-popups-in-tab': false,\r'allow-api-prompt': true,\r'enable-direct-invoke': false,\r'scripturl-mitigation': true,\r'cookie-sync': false,\r'single-session': false,\r'local-network': false,\r'favicon': false,\r'beforeunload': false,\r'ietab-header': false,\r'threaded-popups': false,\r'ie-dialogs': true,\r'show-context-menu': true\r},\r我们通过拜读js源码得知直接在里面添加以下代码，就完成了授权的破解 'licensee': 'fjqisba',\r'license-key': 'https://bbs.pediy.com/'\r5.根据程序名称","date":"2020-09-07","objectID":"/posts/ie-tab%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/:1:0","tags":["浏览器扩展","绿化"],"title":"IE TAB浏览器扩展插件修改过程","uri":"/posts/ie-tab%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"},{"categories":["逆向生涯"],"content":"参考资料 http://open.chrome.360.cn/extension_dev/overview.html ","date":"2020-09-07","objectID":"/posts/ie-tab%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/:2:0","tags":["浏览器扩展","绿化"],"title":"IE TAB浏览器扩展插件修改过程","uri":"/posts/ie-tab%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"},{"categories":["爬虫"],"content":"Puppeteer入门教程 Puppeteer，木偶框架，是谷歌开源的一个浏览器控制框架。它提供了一组可以用来操控Chrome的API，使得我们可以很方便地进行一些浏览器模拟、自动化操作，例如: 生成网页截图或者 PDF 高级爬虫，爬取大量异步渲染内容的网页 模拟键盘输入、表单自动提交、登录网页等，实现 UI 自动化测试 捕获站点的时间线，以便追踪网站，帮助分析网站性能问题 至于为什么选择Puppeteer，而不使用Selenium、CEF等其它框架来模拟浏览器操作，是因为Puppeteer有以下优点: Puppeteer是站在用户使用的角度上来设计操作接口，而不是浏览器的角度，使用起来较为简单、更人性化 由Chrome官方团队进行维护，拥有更好的前景 功能比Selenium更强大，可以很方便地对网络请求进行拦截 使用与浏览器相同的语言，与浏览器衔接更好 Puppeteer同样也有缺点，缺点如下: 只支持Chrome、FireFox浏览器，不支持IE浏览器 只支持NodeJs、C#两种语言 Puppeteer实际上为NodeJs的一个库，NodeJs部署也较为简单，首先到NodeJs官网 https://nodejs.org/en/配置好NodeJs环境。 之后可以在cmd中运行以下指令安装puppeteer库。 npm install puppeteer --save npm介绍: NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 到此puppeteer环境就已经配置好了，如果要编写puppeteer相关的代码，那么还需要配置一下NodeJs的编程环境，可选的编程环境有 webstorm、Visual Studio、VSCode等。这里笔者使用的是Visual Studio，不要问我为什么，Visual Studio天下第一！ 不过在使用Visual Studio的时候，可能会出现一点问题，例如以下代码 var 百度主页 = \"https://www.baidu.com\"; Visual Studio将无法编译通过，这是因为Visual Studio中的源码默认字符集设置问题，需要将字符集编码改为UTF-8。 但是VS 2019隐藏了高级保存功能，导致没办法直接去设置代码编码为UTF-8。具体开启步骤参考如下: 单击“工具”|“自定义”命令，弹出“自定义”对话框。 单击“命令”标签，进入“命令”选项卡。 在“菜单栏”下拉列表中，选择“文件”选项。 单击“添加命令”按钮，弹出“添加命令”对话框。 在“类别”列表中，选择“文件”选项；在“命令”列表中，选择“高级保存选项”选项。 单击“确定”按钮，关闭“添加命令”对话框。 选中“控件”列表中的“高级保存选项”选项，单击“上移”或者“下移”按钮，调整该命令的位置。 单击“关闭”按钮，完成“高级保存选项”命令的添加操作。 之后我们就可以通过高级保存选项来设置源码的字符集编码了。 官方API文档:https://zhaoqize.github.io/puppeteer-api-zh_CN/#/，请务必频繁查看此API文档。 Browser类 一个Browser可以理解成一个浏览器实例，这个类较为简单，使用Browser创建Page例子如下: const puppeteer = require('puppeteer'); puppeteer.launch().then(async browser =\u003e { const page = await browser.newPage(); //浏览器创建一个新标签页 await page.goto('https://www.baidu.com'); //标签页导航到指定网址 await browser.close(); //关闭浏览器 }); Page类 这个类最为关键，可能是要用到的最多的一个类。Page提供对单个标签页进行操作的方法，一个Browser实例可以有多个Page实例。 ","date":"2020-09-01","objectID":"/posts/puppeteer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:0:0","tags":["Puppeteer","自动化","模拟","入门教程"],"title":"Puppeteer入门教程","uri":"/posts/puppeteer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["爬虫"],"content":"实际应用场景模拟 就以爬取百度搜索结果为例吧，目标是爬取出指定搜索结果。 1、新建浏览器，定位到页面 ","date":"2020-09-01","objectID":"/posts/puppeteer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:1:0","tags":["Puppeteer","自动化","模拟","入门教程"],"title":"Puppeteer入门教程","uri":"/posts/puppeteer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["二进制特征码识别"],"content":"相似度对比学习 我们首先从数学的角度去考虑，如何对比两个值是否为相似的呢？ ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:0","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"1、 欧式距离（Euclidean Distance） 欧式距离全称是欧几里距离，是最易于理解的一种距离计算方式，源自欧式空间中两点间的距离公式。 平面空间内的(x1,y1) 与(x2,y2) 间的欧式距离： $$ d=\\sqrt{(x1-x2)^2+(y1-y2)^2} $$ 三维空间里的欧式距离： $$ d=\\sqrt{(x1-x2)^2+(y1-y2)^2+(z1-z2)^2} $$ 当两个点之间的距离为0时，代表两个值完全相似，两个点之间的距离越大，则相似度越低。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:1","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"2、 余弦相似度（Cosine） 在坐标中存在两条向量，通过计算两条向量之间的夹角来对比差异。 平面坐标中向量(x1,y1)与向量(x2,y2)之间可以构成一个三角形，根据三角形余弦夹角公式，得到两个向量之间的夹角计算公式如下： $$ \\cos(\\theta) = \\frac{x1x2+y1y2}{\\sqrt{x1^2+y1^2}\\sqrt{x2^2+y2^2}} $$ 余弦值越接近1，就表明夹角越接近0度，也就是两个向量越相似，夹角等于0，即两个向量相等，这就叫\"余弦相似性”。 欧式距离和夹角余弦的区别： 夹角余弦更能反映两者之间的变动趋势，两者有很高的变化趋势相似度，而欧式距离较大是因为两者数值有很大的区别，即两者拥有很高的数值差异。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:2","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"3、皮尔逊相关系数（Pearson Correlation Coefficient） pearson相关系数p是一个介于[-1,1]之间的值。 如果p=1，称X与Y完全线性相关; 如果p=0，称X与Y无线性关系; 如果p\u003e0，称X与Y正相关; 如果p\u003c0，称X与Y负相关。 如果两个随机变量相关独立，则它们的相关系数为0；如果两个随机变量的相关系数为0，这两个随机变量却未必独立。 皮尔逊相关系数与余弦相似度较为相似。 在数据标准化后，Pearson相关性系数、Cosine相似度、欧式距离的平方可认为是等价的。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:3","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"4、汉明距离（Hamming distance） 汉明距离可以理解为两个向量中不相等的值的个数。 例如X为1001，Y为1110，不同的值有3个，汉明距离就是3。 其实说简单点就是暴力对比，相同的点位越多，越相似。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:4","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"5、曼哈顿距离（Manhattan Distance） 在平面上，坐标(x1,y1)与坐标(x2,y2)之间的曼哈顿距离为: $$ d = |x1-x2|+|y1-y2| $$ ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:5","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["杂文"],"content":"Git学习笔记 ","date":"2020-08-23","objectID":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["笔记","Git"],"title":"Git学习笔记","uri":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["杂文"],"content":"克隆含有子模块的项目 当一个git项目含有子模块(submodule)时，直接克隆下来的子模块目录里面是空的。 这时可以在执行git clone时加上–recursive参数，它会自动初始化并更新每一个子模块，例如 git clone --recursive https://github.com/x64dbg/x64dbg.git 如果项目已经克隆到了本地，执行下面的步骤： 1.初始化本地子模块配置文件 git submodule init 2.更新项目，抓取子模块内容。 git submodule update ","date":"2020-08-23","objectID":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":["笔记","Git"],"title":"Git学习笔记","uri":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["杂文"],"content":"配置IDA环境 当前IDA能用的版本勉强只有一个泄露出安装包+跑出安装包Key的IDA 7.2版本 + x64 Hex-Rays 可以参考一下此文档: https://github.com/jas502n/IDA_Pro_7.2 由于没有完整的Hex-Rays插件，因此只好去杂交7.0版本的Hex-Rays，插件在此下载。 下载完成后覆盖在IDA目录下，即可拥有IDA7.2 + 7.0 Hex-Rays。 展望未来 目前发现一个IDA7.4比较完整的安装包，但是尚未跑出Key，个人觉得比较悬了，暂且关注一下吧 https://bbs.pediy.com/thread-261050-1.htm ","date":"2020-08-17","objectID":"/posts/%E9%85%8D%E7%BD%AEida%E7%8E%AF%E5%A2%83/:0:0","tags":["IDA"],"title":"配置IDA环境","uri":"/posts/%E9%85%8D%E7%BD%AEida%E7%8E%AF%E5%A2%83/"},{"categories":["杂文"],"content":"ZyDis反汇编引擎 Zydis是一个开源的反汇编引擎，项目地址如下: https://github.com/zyantific/zydis ","date":"2020-08-16","objectID":"/posts/zydis%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/:0:0","tags":["反汇编引擎"],"title":"ZyDis反汇编引擎","uri":"/posts/zydis%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/"},{"categories":["杂文"],"content":"配置ZyDis库 1.克隆存储库，得到Zydis源码。 2.由于笔者使用的是Windows平台下的Visual Studio环境，因此可以直接运行源码目录zydis\\msvc\\Zydis.sln的工程。 3.在工程中编译库，大致分为DLL动态库或者静态库两种方式，笔者比较喜欢静态编译的方式，因此工程配置选择Release MT，编译x86和x64两个版本的库。 4.提取出include头文件和lib文件，即得到反汇编引擎库。 或者直接点击此下载 ","date":"2020-08-16","objectID":"/posts/zydis%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/:0:1","tags":["反汇编引擎"],"title":"ZyDis反汇编引擎","uri":"/posts/zydis%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/"},{"categories":["杂文"],"content":"使用Zydis库 新建一个测试工程 1.附加包含目录中添加Zydis\\include 2.附加库目录视编译平台选择Zydis\\lib\\X86或者Zydis\\lib\\X64 3.附加依赖项中添加Zycore.lib和Zydis.lib 4.预处理器定义中添加两行 ZYCORE_STATIC_DEFINE\rZYDIS_STATIC_DEFINE\r编写代码进行测试，可以正常地使用Zydis库函数，则代表反汇编引擎配置成功! ","date":"2020-08-16","objectID":"/posts/zydis%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/:0:2","tags":["反汇编引擎"],"title":"ZyDis反汇编引擎","uri":"/posts/zydis%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/"},{"categories":["心情文学"],"content":"由于没有任何工作经验,大老远跑来北京实习,住在这边的公租房实习生宿舍,获取网络成了我第一个要解决的问题. 幻影WIFI暴力枚举的话我并不是很喜欢,幻影PIN倒是可以用来搞那些开了WPS的旧版路由器,可惜我的手机并没有完整的ROOT权限. 于是我下载了一个万能钥匙显密码版,扫了一下,只发现一个能用的WIFI——JIUBUGAOSUNI, 然而这个WIFI信号质量太差了,我必须将我的笔记本放在窗边才能勉强得到较好的网速… 于是我查看了一下网关,进入路由器后台,熟悉的斐讯K2界面..填路由器管理员密码,我试了试WIFI密码,结果一试就中… 我将路由器带宽改成了20MHZ,信道试了试13号,似乎信号有了明显的小改善,可是信号质量依旧还是不稳定. 我不得不会会一个信号质量更好点的WIFI,小米共享WIFI,首先光听名字就感觉有点东西,这是我一开始不愿意接触这个的理由. 在查询了一些关于这个WIFI的资料后,发现: 这个WIFI每个客户每次上网都需要访问一个访问网络地址,每次只能免费3分钟,3分钟过后想要联网就必须得重新访问,而且重复次数达到一定次数就提示免费次数已达到上限,不给用网了. 对这个协议进行了小小的分析,发现要想联网只需访问 http://api.miwifi.com/wifirent/api/ad_apply_rent?callback=jsonpCallback\u0026router_id=06136143-ce88-1b71-fe90-e9479fe1fd4d\u0026client_info=1THJz%2BvESwpnKmn6RtvxtrJEyra%2BgBFDjl9Z7vBOMFtwMD5gmH8PsAPUS3MP1wnR 这个地址即可, 其中只有两个参数,router_id是路由器设备号,client_info是包含用户MAC地址在内的加密字符串. 仔细想想,如果我是一台控制路由器的服务器,客户要想连我的网,就必须发送给我MAC地址,那么我对此MAC地址进行计时,只允许使用3分钟,再进行计次,每隔N小时只能使用3次,那么站在程序员的角度来说, 客户是无论怎样试图篡改网络协议中的参数,也是没办法突破小米路由器的限制,来达到单MAC地址无限使用网络的.毕竟功能在服务器上面,逆向破解软件的我对此深有体会… 那么这样就没有必要再继续研究下去了,我发现整个流程中唯一我能攻击的漏洞就在于每个用户能体验三分钟网络本身. 我下载了一个TMAC(修改MAC地址),结合自动联网程序(易语言简单迅速),不到一会就开发出了一个简易的暴力联网程序. 该程序每隔一段时间随机修改MAC地址,然后访问联网API进行联网,总之我暂时是能舒服地用这个带宽10MB的网络了(打游戏还是有点勉强….) ","date":"2018-11-17","objectID":"/posts/%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E5%B0%8F%E8%AE%B0/:0:0","tags":["实习"],"title":"获取网络小记","uri":"/posts/%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E5%B0%8F%E8%AE%B0/"},{"categories":null,"content":"fjqisba，毕业于南京邮电大学软件工程系。 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"作者信息","uri":"/about/"}]