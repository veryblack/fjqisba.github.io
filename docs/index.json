[{"categories":["逆向生涯"],"content":"IE TAB浏览器扩展插件修改过程 事情是这样的，我在使用Puppeteer框架对网站进行爬取的时候，发现有些页面使用到了ActiveX控件。众所周知，只有IE浏览器才支持ActiveX控件，而Puppeteer却不支持IE浏览器！这导致我在爬取的过程中页面无法正常加载，这样一来我也就截取不到我想要的一些请求了。 在尝试解决该问题的过程我了解到了IE TAB，IE Tab 是网页浏览器的一个扩展插件，支持Firefox/Chrome。 IE TAB应用场景: 有些网站页面格式不标准，或者使用到了ActiveX控件，只能在IE浏览器中正常显示。而这个时候我们又想在Chrome/FireFox浏览器中访问此网站，这个时候就可以使用IE TAB插件，此插件主要功能是通过调用Internet Explorer的引擎来访问网页，解决一些网页无法在当前标准的浏览器中正常显示的问题。 该软件安装使用可能要用到科学上网，软件分免费版和授权版两种。 免费版能满足普通用户的大部分使用需求，但是对选项进行设置需要进行联网。 授权版有着GPO组策略部署等更方便好用的功能(不知道是啥玩意。。。)。 于是我便打算对IE TAB进行个人修改(去除一些我不想要的功能，添加我想要的功能)。 ","date":"2020-09-07","objectID":"/posts/ie-tab%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/:0:0","tags":["浏览器扩展 绿化"],"title":"IE TAB浏览器扩展插件修改过程","uri":"/posts/ie-tab%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"},{"categories":["逆向生涯"],"content":"知识点归纳 1.程序ietabhelper.exe会释放一个文件ietab_nm_manifest.json至目录C:\\Users\\fjqisba\\AppData\\Local\\IE Tab下，同时在注册表SOFTWARE\\Google\\Chrome\\NativeMessagingHosts\\net.ietab.ietabhelper.peruser中写入该json文件路径。这样的目的其实是为了注册本地消息主机。 本地消息主机(Native messaging): 通过将浏览器所在客户端的本地应用注册为本地消息主机，Chrome浏览器扩展可以和本地应用之间收发消息。 本地应用要想成为\"本地消息主机”，必须有一个有效的json配置文件，例如: { \"name\": \"com.my_company.my_application\", \"description\": \"My Application\", \"path\": \"C:\\\\MyApplication.exe\", \"type\": \"stdio\", \"allowed_origins\": [ \"chrome-extension://ndbehkpfbjcaflobmibchkjiphgibnid/\" ] } 其中path为本地应用的执行路径；allowed_origins为授权能够与本地消息主机进行通讯的浏览器扩展，不得有通配符。 之后在安装本地应用时需要在注册表中指明配置文件的路径，例如创建key HKEY_CURRENT_USER\\SOFTWARE\\Google\\Chrome\\NativeMessagingHosts\\com.my_company.my_application 设置默认值Default为配置文件所在的绝对路径。 程序注册了本地消息主机，是为了让浏览器扩展和程序自带的ietabhelper.exe进行通讯，个人推测一些核心功能其实是在ietabhelper.exe中，例如调用IE浏览器引擎等。 很明显我们在重新打包扩展插件的时候，浏览器扩展插件的id会发生变化，因此我们需要修改配置文件中allowed_origins的内容，allowed_origins内容其实来源于ietabhelper.exe中，我们可以对该exe进行patch，加入我们自己的浏览器扩展插件id。 2.在nathost_manager.js中似乎对浏览器扩展ID还有判断，先不管对不对，加上自己的ID就完事了。 _updateAllowedOrigins: function(manifestContent) { // hehijbfgiekmjfkfjpbkbammjbdenadd - Chrome Web Store release // knnoopddfdgdabjanjmeodpkmlhapkkl - IE Tab Enterprise edition // ncdgipmkgkhennagnfmnlkflidilhbdi - IE Tab Enterprise self-deployed // npjkkakdacjaihjaoeliacmecofghagh - Windows Store for Edge // almljgkjodjgoldenkijomojnejpkcjk - IE Tab Beta for Chrome var origins = [ 'chrome-extension://hehijbfgiekmjfkfjpbkbammjbdenadd/', 'chrome-extension://knnoopddfdgdabjanjmeodpkmlhapkkl/', 'chrome-extension://ncdgipmkgkhennagnfmnlkflidilhbdi/', 'chrome-extension://npjkkakdacjaihjaoeliacmecofghagh/', 'chrome-extension://almljgkjodjgoldenkijomojnejpkcjk/' ]; var me = chrome.extension.getURL(''); if ( (origins[0] != me) \u0026\u0026 (origins[1] != me)) { origins.push(me); } var cleanOrigins = JSON.stringify(origins); cleanOrigins = cleanOrigins.replace(/[\\[\\]]/g, ''); return manifestContent.replace('ALLOWED_ORIGINS', cleanOrigins); }, 3.在进行选项设置的时候，你需要访问http://www.ietab.net/options这个网址才行，其实就软件功能来说，理应可以实现完全本地化的，但是作者非要你访问他的官网，这里我们直接将options.html给离线存储下来，相应的服务器js、html、css也保存到本地，再修正一下HTML引用的文件URL。 之后我们还需要修改一下程序的配置，在manifest.json中有一个值为content_scripts，简要介绍如下: Content scripts是在Web页面内运行的javascript脚本。通过使用标准的DOM，它们可以获取浏览器所访问页面的详细信息，并可以修改这些信息。 下面是content scipt可以做的一些事情范例： 从页面中找到没有写成超链接形式的url，并将它们转成超链接。 放大页面字体使文字更清晰 找到并处理DOM中的microformat 当然，content scripts也有一些限制，它们不能做的事情包括 ： 不能使用除了chrome.extension之外的chrome.* 的接口 不能访问它所在扩展中定义的函数和变量 不能访问web页面或其它content script中定义的函数和变量 不能做cross-site XMLHttpRequests 这些限制其实并不像看上去那么糟糕。Content scripts 可以使用messages机制与它所在的扩展通信，来间接使用chrome.*接口，或访问扩展数据。Content scripts还可以通过共享的DOM来与web页面通信。 总之，可以理解为一个页面注入js，而IE TAB存在这么一个配置 content_scripts\": [ { \"js\": [ \"js/extapi_cs.js\" ], \"matches\": [ \"*://*.ietab.net/*\" ], \"run_at\": \"document_start\" } ] 意思就是，程序在访问http://www.ietab.net/options这个网址时，便会注入extapi_cs.js这个js，这个js非常关键，涉及到核心功能之间的相互通讯，如果没有的话那么功能会无法执行起来。由于我们本地化了options.html，因此我们也需要注入这个js，其实方式也很简单，我们可以直接在options.html中加入下列代码 \u003cscript src=\"js/extapi_cs.js\"\u003e\u003c/script\u003e 这样便完成了和原程序一样的注入。 4.软件使用到了localStorage来存储配置选项信息+授权信息，在Settings.js中存在以下代码，为程序加载的一些默认项 localStorage为浏览器的本地存储机制，存储时间理论上来说是永久有效的，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。 DEFAULT_SETTINGS: {\r'compat-mode': 'IE7S',\r'disable-intro-page': false,\r'enable-auto-urls': true,\r'enable-chrome-popups': true,\r'settings-refresh-interval': 1000*60*10, // Every 10 minutes\r'show-search-box': false,\r'enable-use-full-window-popups': true,\r'enable-dep': true,\r'enable-atl-dep': true,\r'only-auto-urls' : false,\r'hide-addr-bar' : false,\r'show-status-text' : false,\r'open-popups-in-tab': false,\r'allow-api-prompt': true,\r'enable-direct-invoke': false,\r'scripturl-mitigation': true,\r'cookie-sync': false,\r'single-session': false,\r'local-network': false,\r'favicon': false,\r'beforeunload': false,\r'ietab-header': false,\r'threaded-popups': false,\r'ie-dialogs': true,\r'show-context-menu': true\r},\r我们通过拜读js源码得知直接在里面添加以下代码，就完成了授权的破解 'licensee': 'fjqisba',\r'license-key': 'https://bbs.pediy.com/'\r5.根据程序名称","date":"2020-09-07","objectID":"/posts/ie-tab%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/:1:0","tags":["浏览器扩展 绿化"],"title":"IE TAB浏览器扩展插件修改过程","uri":"/posts/ie-tab%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"},{"categories":["逆向生涯"],"content":"参考资料 http://open.chrome.360.cn/extension_dev/overview.html ","date":"2020-09-07","objectID":"/posts/ie-tab%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/:2:0","tags":["浏览器扩展 绿化"],"title":"IE TAB浏览器扩展插件修改过程","uri":"/posts/ie-tab%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"},{"categories":["Puppeteer"],"content":"Puppeteer入门教程 Puppeteer，木偶框架，是谷歌开源的一个浏览器控制框架。它提供了一组可以用来操控Chrome的API，使得我们可以很方便地进行一些浏览器模拟、自动化操作，例如: 生成网页截图或者 PDF 高级爬虫，爬取大量异步渲染内容的网页 模拟键盘输入、表单自动提交、登录网页等，实现 UI 自动化测试 捕获站点的时间线，以便追踪网站，帮助分析网站性能问题 至于为什么选择Puppeteer，而不使用Selenium、CEF等其它框架来模拟浏览器操作，是因为Puppeteer有以下优点: Puppeteer是站在用户使用的角度上来设计操作接口，而不是浏览器的角度，使用起来较为简单、更人性化 由Chrome官方团队进行维护，拥有更好的前景 功能比Selenium更强大，可以很方便地对网络请求进行拦截 使用与浏览器相同的语言，与浏览器衔接更好 Puppeteer同样也有缺点，缺点如下: 只支持Chrome、FireFox浏览器，不支持IE浏览器 只支持NodeJs、C#两种语言 Puppeteer实际上为NodeJs的一个库，NodeJs部署也较为简单，首先到NodeJs官网 https://nodejs.org/en/配置好NodeJs环境。 之后可以在cmd中运行以下指令安装puppeteer库。 npm install puppeteer --save npm介绍: NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 到此puppeteer环境就已经配置好了，如果要编写puppeteer相关的代码，那么还需要配置一下NodeJs的编程环境，可选的编程环境有 webstorm、Visual Studio、VSCode等。这里笔者使用的是Visual Studio，不要问我为什么，Visual Studio天下第一！ 不过在使用Visual Studio的时候，可能会出现一点问题，例如以下代码 var 百度主页 = \"https://www.baidu.com\"; Visual Studio将无法编译通过，这是因为Visual Studio中的源码默认字符集设置问题，需要将字符集编码改为UTF-8。 但是VS 2019隐藏了高级保存功能，导致没办法直接去设置代码编码为UTF-8。具体开启步骤参考如下: 单击“工具”|“自定义”命令，弹出“自定义”对话框。 单击“命令”标签，进入“命令”选项卡。 在“菜单栏”下拉列表中，选择“文件”选项。 单击“添加命令”按钮，弹出“添加命令”对话框。 在“类别”列表中，选择“文件”选项；在“命令”列表中，选择“高级保存选项”选项。 单击“确定”按钮，关闭“添加命令”对话框。 选中“控件”列表中的“高级保存选项”选项，单击“上移”或者“下移”按钮，调整该命令的位置。 单击“关闭”按钮，完成“高级保存选项”命令的添加操作。 之后我们就可以通过高级保存选项来设置源码的字符集编码了。 官方API文档:https://zhaoqize.github.io/puppeteer-api-zh_CN/#/，请务必频繁查看此API文档。 Browser类 一个Browser可以理解成一个浏览器实例，这个类较为简单，使用Browser创建Page例子如下: const puppeteer = require('puppeteer'); puppeteer.launch().then(async browser =\u003e { const page = await browser.newPage(); //浏览器创建一个新标签页 await page.goto('https://www.baidu.com'); //标签页导航到指定网址 await browser.close(); //关闭浏览器 }); Page类 这个类最为关键，可能是要用到的最多的一个类。Page提供对单个标签页进行操作的方法，一个Browser实例可以有多个Page实例。 ","date":"2020-09-01","objectID":"/posts/puppeteer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:0:0","tags":["浏览器","自动化","模拟","入门教程"],"title":"Puppeteer入门教程","uri":"/posts/puppeteer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["Puppeteer"],"content":"实际应用场景模拟 就以爬取百度搜索结果为例吧，目标是爬取出指定搜索结果。 1、新建浏览器，定位到页面 ","date":"2020-09-01","objectID":"/posts/puppeteer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:1:0","tags":["浏览器","自动化","模拟","入门教程"],"title":"Puppeteer入门教程","uri":"/posts/puppeteer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["二进制特征码识别"],"content":"相似度对比学习 我们首先从数学的角度去考虑，如何对比两个值是否为相似的呢？ ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:0","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"1、 欧式距离（Euclidean Distance） 欧式距离全称是欧几里距离，是最易于理解的一种距离计算方式，源自欧式空间中两点间的距离公式。 平面空间内的(x1,y1) 与(x2,y2) 间的欧式距离： $$ d=\\sqrt{(x1-x2)^2+(y1-y2)^2} $$ 三维空间里的欧式距离： $$ d=\\sqrt{(x1-x2)^2+(y1-y2)^2+(z1-z2)^2} $$ 当两个点之间的距离为0时，代表两个值完全相似，两个点之间的距离越大，则相似度越低。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:1","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"2、 余弦相似度（Cosine） 在坐标中存在两条向量，通过计算两条向量之间的夹角来对比差异。 平面坐标中向量(x1,y1)与向量(x2,y2)之间可以构成一个三角形，根据三角形余弦夹角公式，得到两个向量之间的夹角计算公式如下： $$ \\cos(\\theta) = \\frac{x1x2+y1y2}{\\sqrt{x1^2+y1^2}\\sqrt{x2^2+y2^2}} $$ 余弦值越接近1，就表明夹角越接近0度，也就是两个向量越相似，夹角等于0，即两个向量相等，这就叫\"余弦相似性”。 欧式距离和夹角余弦的区别： 夹角余弦更能反映两者之间的变动趋势，两者有很高的变化趋势相似度，而欧式距离较大是因为两者数值有很大的区别，即两者拥有很高的数值差异。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:2","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"3、皮尔逊相关系数（Pearson Correlation Coefficient） pearson相关系数p是一个介于[-1,1]之间的值。 如果p=1，称X与Y完全线性相关; 如果p=0，称X与Y无线性关系; 如果p\u003e0，称X与Y正相关; 如果p\u003c0，称X与Y负相关。 如果两个随机变量相关独立，则它们的相关系数为0；如果两个随机变量的相关系数为0，这两个随机变量却未必独立。 皮尔逊相关系数与余弦相似度较为相似。 在数据标准化后，Pearson相关性系数、Cosine相似度、欧式距离的平方可认为是等价的。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:3","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"4、汉明距离（Hamming distance） 汉明距离可以理解为两个向量中不相等的值的个数。 例如X为1001，Y为1110，不同的值有3个，汉明距离就是3。 其实说简单点就是暴力对比，相同的点位越多，越相似。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:4","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"5、曼哈顿距离（Manhattan Distance） 在平面上，坐标(x1,y1)与坐标(x2,y2)之间的曼哈顿距离为: $$ d = |x1-x2|+|y1-y2| $$ ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:5","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["杂文"],"content":"Git学习笔记 ","date":"2020-08-23","objectID":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["git"],"title":"Git学习笔记","uri":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["杂文"],"content":"克隆含有子模块的项目 当一个git项目含有子模块(submodule)时，直接克隆下来的子模块目录里面是空的。 这时可以在执行git clone时加上–recursive参数，它会自动初始化并更新每一个子模块，例如 git clone --recursive https://github.com/x64dbg/x64dbg.git 如果项目已经克隆到了本地，执行下面的步骤： 1.初始化本地子模块配置文件 git submodule init 2.更新项目，抓取子模块内容。 git submodule update ","date":"2020-08-23","objectID":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":["git"],"title":"Git学习笔记","uri":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["杂文"],"content":"配置IDA环境 当前IDA能用的版本勉强只有一个泄露出安装包+跑出安装包Key的IDA 7.2版本 + x64 Hex-Rays 可以参考一下此文档: https://github.com/jas502n/IDA_Pro_7.2 由于没有完整的Hex-Rays插件，因此只好去杂交7.0版本的Hex-Rays，插件在此下载。 下载完成后覆盖在IDA目录下，即可拥有IDA7.2 + 7.0 Hex-Rays。 展望未来 目前发现一个IDA7.4比较完整的安装包，但是尚未跑出Key，个人觉得比较悬了，暂且关注一下吧 https://bbs.pediy.com/thread-261050-1.htm ","date":"2020-08-17","objectID":"/posts/%E9%85%8D%E7%BD%AEida%E7%8E%AF%E5%A2%83/:0:0","tags":["IDA"],"title":"配置IDA环境","uri":"/posts/%E9%85%8D%E7%BD%AEida%E7%8E%AF%E5%A2%83/"},{"categories":["杂文"],"content":"ZyDis反汇编引擎 Zydis是一个开源的反汇编引擎，项目地址如下: https://github.com/zyantific/zydis ","date":"2020-08-16","objectID":"/posts/zydis%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/:0:0","tags":["反汇编引擎"],"title":"ZyDis反汇编引擎","uri":"/posts/zydis%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/"},{"categories":["杂文"],"content":"配置ZyDis库 1.克隆存储库，得到Zydis源码。 2.由于笔者使用的是Windows平台下的Visual Studio环境，因此可以直接运行源码目录zydis\\msvc\\Zydis.sln的工程。 3.在工程中编译库，大致分为DLL动态库或者静态库两种方式，笔者比较喜欢静态编译的方式，因此工程配置选择Release MT，编译x86和x64两个版本的库。 4.提取出include头文件和lib文件，即得到反汇编引擎库。 或者直接点击此下载 ","date":"2020-08-16","objectID":"/posts/zydis%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/:0:1","tags":["反汇编引擎"],"title":"ZyDis反汇编引擎","uri":"/posts/zydis%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/"},{"categories":["杂文"],"content":"使用Zydis库 新建一个测试工程 1.附加包含目录中添加Zydis\\include 2.附加库目录视编译平台选择Zydis\\lib\\X86或者Zydis\\lib\\X64 3.附加依赖项中添加Zycore.lib和Zydis.lib 4.预处理器定义中添加两行 ZYCORE_STATIC_DEFINE\rZYDIS_STATIC_DEFINE\r编写代码进行测试，可以正常地使用Zydis库函数，则代表反汇编引擎配置成功! ","date":"2020-08-16","objectID":"/posts/zydis%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/:0:2","tags":["反汇编引擎"],"title":"ZyDis反汇编引擎","uri":"/posts/zydis%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/"},{"categories":["心情文学"],"content":"由于没有任何工作经验,大老远跑来北京实习,住在这边的公租房实习生宿舍,获取网络成了我第一个要解决的问题. 幻影WIFI暴力枚举的话我并不是很喜欢,幻影PIN倒是可以用来搞那些开了WPS的旧版路由器,可惜我的手机并没有完整的ROOT权限. 于是我下载了一个万能钥匙显密码版,扫了一下,只发现一个能用的WIFI——JIUBUGAOSUNI, 然而这个WIFI信号质量太差了,我必须将我的笔记本放在窗边才能勉强得到较好的网速… 于是我查看了一下网关,进入路由器后台,熟悉的斐讯K2界面..填路由器管理员密码,我试了试WIFI密码,结果一试就中… 我将路由器带宽改成了20MHZ,信道试了试13号,似乎信号有了明显的小改善,可是信号质量依旧还是不稳定. 我不得不会会一个信号质量更好点的WIFI,小米共享WIFI,首先光听名字就感觉有点东西,这是我一开始不愿意接触这个的理由. 在查询了一些关于这个WIFI的资料后,发现: 这个WIFI每个客户每次上网都需要访问一个访问网络地址,每次只能免费3分钟,3分钟过后想要联网就必须得重新访问,而且重复次数达到一定次数就提示免费次数已达到上限,不给用网了. 对这个协议进行了小小的分析,发现要想联网只需访问 http://api.miwifi.com/wifirent/api/ad_apply_rent?callback=jsonpCallback\u0026router_id=06136143-ce88-1b71-fe90-e9479fe1fd4d\u0026client_info=1THJz%2BvESwpnKmn6RtvxtrJEyra%2BgBFDjl9Z7vBOMFtwMD5gmH8PsAPUS3MP1wnR 这个地址即可, 其中只有两个参数,router_id是路由器设备号,client_info是包含用户MAC地址在内的加密字符串. 仔细想想,如果我是一台控制路由器的服务器,客户要想连我的网,就必须发送给我MAC地址,那么我对此MAC地址进行计时,只允许使用3分钟,再进行计次,每隔N小时只能使用3次,那么站在程序员的角度来说, 客户是无论怎样试图篡改网络协议中的参数,也是没办法突破小米路由器的限制,来达到单MAC地址无限使用网络的.毕竟功能在服务器上面,逆向破解软件的我对此深有体会… 那么这样就没有必要再继续研究下去了,我发现整个流程中唯一我能攻击的漏洞就在于每个用户能体验三分钟网络本身. 我下载了一个TMAC(修改MAC地址),结合自动联网程序(易语言简单迅速),不到一会就开发出了一个简易的暴力联网程序. 该程序每隔一段时间随机修改MAC地址,然后访问联网API进行联网,总之我暂时是能舒服地用这个带宽10MB的网络了(打游戏还是有点勉强….) ","date":"2018-11-17","objectID":"/posts/%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E5%B0%8F%E8%AE%B0/:0:0","tags":["实习"],"title":"获取网络小记","uri":"/posts/%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E5%B0%8F%E8%AE%B0/"},{"categories":null,"content":"fjqisba，毕业于南京邮电大学软件工程系。 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"作者信息","uri":"/about/"}]