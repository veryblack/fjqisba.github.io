[{"categories":["Puppeteer"],"content":"Puppeteer入门教程 Puppeteer，木偶框架，是谷歌开源的一个浏览器控制框架。它提供了一组可以用来操控Chrome的API，使得我们可以很方便地进行一些浏览器模拟、自动化操作，例如: 生成网页截图或者 PDF 高级爬虫，爬取大量异步渲染内容的网页 模拟键盘输入、表单自动提交、登录网页等，实现 UI 自动化测试 捕获站点的时间线，以便追踪网站，帮助分析网站性能问题 //To do…为什么选择Puppeteer Puppeteer实际上为NodeJs的一个库，NodeJs部署也较为简单，首先到NodeJs官网 https://nodejs.org/en/配置好NodeJs环境。 之后可以在cmd中运行以下指令安装puppeteer库。 npm install puppeteer --save npm介绍: NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 到此puppeteer环境就已经配置好了，如果要编写puppeteer相关的代码，那么还需要配置一下NodeJs的编程环境: 新手推荐使用webstorm 老鸟推荐使用VSCode 大神可以直接使用记事本来编写代码，使用命令行node xx.js来运行。 官方入门的 DEMO如下: const puppeteer = require('puppeteer'); (async () =\u003e { const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto('https://www.baidu.com'); await page.screenshot({path: 'example.png'}); await browser.close(); })(); 运行上面这段JS后，便会在目录下生成百度页面的截图了。 ","date":"2020-09-01","objectID":"/posts/puppeteer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:0:0","tags":["浏览器","自动化","模拟","入门教程"],"title":"Puppeteer入门教程","uri":"/posts/puppeteer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["二进制特征码识别"],"content":"相似度对比学习 我们首先从数学的角度去考虑，如何对比两个值是否为相似的呢？ ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:0","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"1、 欧式距离（Euclidean Distance） 欧式距离全称是欧几里距离，是最易于理解的一种距离计算方式，源自欧式空间中两点间的距离公式。 平面空间内的(x1,y1) 与(x2,y2) 间的欧式距离： $$ d=\\sqrt{(x1-x2)^2+(y1-y2)^2} $$ 三维空间里的欧式距离： $$ d=\\sqrt{(x1-x2)^2+(y1-y2)^2+(z1-z2)^2} $$ 当两个点之间的距离为0时，代表两个值完全相似，两个点之间的距离越大，则相似度越低。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:1","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"2、 余弦相似度（Cosine） 在坐标中存在两条向量，通过计算两条向量之间的夹角来对比差异。 平面坐标中向量(x1,y1)与向量(x2,y2)之间可以构成一个三角形，根据三角形余弦夹角公式，得到两个向量之间的夹角计算公式如下： $$ \\cos(\\theta) = \\frac{x1x2+y1y2}{\\sqrt{x1^2+y1^2}\\sqrt{x2^2+y2^2}} $$ 余弦值越接近1，就表明夹角越接近0度，也就是两个向量越相似，夹角等于0，即两个向量相等，这就叫\"余弦相似性”。 欧式距离和夹角余弦的区别： 夹角余弦更能反映两者之间的变动趋势，两者有很高的变化趋势相似度，而欧式距离较大是因为两者数值有很大的区别，即两者拥有很高的数值差异。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:2","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"3、皮尔逊相关系数（Pearson Correlation Coefficient） pearson相关系数p是一个介于[-1,1]之间的值。 如果p=1，称X与Y完全线性相关; 如果p=0，称X与Y无线性关系; 如果p\u003e0，称X与Y正相关; 如果p\u003c0，称X与Y负相关。 如果两个随机变量相关独立，则它们的相关系数为0；如果两个随机变量的相关系数为0，这两个随机变量却未必独立。 皮尔逊相关系数与余弦相似度较为相似。 在数据标准化后，Pearson相关性系数、Cosine相似度、欧式距离的平方可认为是等价的。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:3","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"4、汉明距离（Hamming distance） 汉明距离可以理解为两个向量中不相等的值的个数。 例如X为1001，Y为1110，不同的值有3个，汉明距离就是3。 其实说简单点就是暴力对比，相同的点位越多，越相似。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:4","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"5、曼哈顿距离（Manhattan Distance） 在平面上，坐标(x1,y1)与坐标(x2,y2)之间的曼哈顿距离为: $$ d = |x1-x2|+|y1-y2| $$ ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:5","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["杂文"],"content":"Git学习笔记 ","date":"2020-08-23","objectID":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["git"],"title":"Git学习笔记","uri":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["杂文"],"content":"克隆含有子模块的项目 当一个git项目含有子模块(submodule)时，直接克隆下来的子模块目录里面是空的。 这时可以在执行git clone时加上–recursive参数，它会自动初始化并更新每一个子模块，例如 git clone --recursive https://github.com/x64dbg/x64dbg.git 如果项目已经克隆到了本地，执行下面的步骤： 1.初始化本地子模块配置文件 git submodule init 2.更新项目，抓取子模块内容。 git submodule update ","date":"2020-08-23","objectID":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":["git"],"title":"Git学习笔记","uri":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["杂文"],"content":"配置IDA环境 当前IDA能用的版本勉强只有一个泄露出安装包+跑出安装包Key的IDA 7.2版本 + x64 Hex-Rays 可以参考一下此文档: https://github.com/jas502n/IDA_Pro_7.2 由于没有完整的Hex-Rays插件，因此只好去杂交7.0版本的Hex-Rays，插件在此下载。 下载完成后覆盖在IDA目录下，即可拥有IDA7.2 + 7.0 Hex-Rays。 展望未来 目前发现一个IDA7.4比较完整的安装包，但是尚未跑出Key，个人觉得比较悬了，暂且关注一下吧 https://bbs.pediy.com/thread-261050-1.htm ","date":"2020-08-17","objectID":"/posts/%E9%85%8D%E7%BD%AEida%E7%8E%AF%E5%A2%83/:0:0","tags":["IDA"],"title":"配置IDA环境","uri":"/posts/%E9%85%8D%E7%BD%AEida%E7%8E%AF%E5%A2%83/"},{"categories":["杂文"],"content":"ZyDis反汇编引擎 Zydis是一个开源的反汇编引擎，项目地址如下: https://github.com/zyantific/zydis ","date":"2020-08-16","objectID":"/posts/zydis%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/:0:0","tags":["反汇编引擎"],"title":"ZyDis反汇编引擎","uri":"/posts/zydis%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/"},{"categories":["杂文"],"content":"配置ZyDis库 1.克隆存储库，得到Zydis源码。 2.由于笔者使用的是Windows平台下的Visual Studio环境，因此可以直接运行源码目录zydis\\msvc\\Zydis.sln的工程。 3.在工程中编译库，大致分为DLL动态库或者静态库两种方式，笔者比较喜欢静态编译的方式，因此工程配置选择Release MT，编译x86和x64两个版本的库。 4.提取出include头文件和lib文件，即得到反汇编引擎库。 或者直接点击此下载 ","date":"2020-08-16","objectID":"/posts/zydis%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/:0:1","tags":["反汇编引擎"],"title":"ZyDis反汇编引擎","uri":"/posts/zydis%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/"},{"categories":["杂文"],"content":"使用Zydis库 新建一个测试工程 1.附加包含目录中添加Zydis\\include 2.附加库目录视编译平台选择Zydis\\lib\\X86或者Zydis\\lib\\X64 3.附加依赖项中添加Zycore.lib和Zydis.lib 4.预处理器定义中添加两行 ZYCORE_STATIC_DEFINE\rZYDIS_STATIC_DEFINE\r编写代码进行测试，可以正常地使用Zydis库函数，则代表反汇编引擎配置成功! ","date":"2020-08-16","objectID":"/posts/zydis%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/:0:2","tags":["反汇编引擎"],"title":"ZyDis反汇编引擎","uri":"/posts/zydis%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/"},{"categories":["心情文学"],"content":"由于没有任何工作经验,大老远跑来北京实习,住在这边的公租房实习生宿舍,获取网络成了我第一个要解决的问题. 幻影WIFI暴力枚举的话我并不是很喜欢,幻影PIN倒是可以用来搞那些开了WPS的旧版路由器,可惜我的手机并没有完整的ROOT权限. 于是我下载了一个万能钥匙显密码版,扫了一下,只发现一个能用的WIFI——JIUBUGAOSUNI, 然而这个WIFI信号质量太差了,我必须将我的笔记本放在窗边才能勉强得到较好的网速… 于是我查看了一下网关,进入路由器后台,熟悉的斐讯K2界面..填路由器管理员密码,我试了试WIFI密码,结果一试就中… 我将路由器带宽改成了20MHZ,信道试了试13号,似乎信号有了明显的小改善,可是信号质量依旧还是不稳定. 我不得不会会一个信号质量更好点的WIFI,小米共享WIFI,首先光听名字就感觉有点东西,这是我一开始不愿意接触这个的理由. 在查询了一些关于这个WIFI的资料后,发现: 这个WIFI每个客户每次上网都需要访问一个访问网络地址,每次只能免费3分钟,3分钟过后想要联网就必须得重新访问,而且重复次数达到一定次数就提示免费次数已达到上限,不给用网了. 对这个协议进行了小小的分析,发现要想联网只需访问 http://api.miwifi.com/wifirent/api/ad_apply_rent?callback=jsonpCallback\u0026router_id=06136143-ce88-1b71-fe90-e9479fe1fd4d\u0026client_info=1THJz%2BvESwpnKmn6RtvxtrJEyra%2BgBFDjl9Z7vBOMFtwMD5gmH8PsAPUS3MP1wnR 这个地址即可, 其中只有两个参数,router_id是路由器设备号,client_info是包含用户MAC地址在内的加密字符串. 仔细想想,如果我是一台控制路由器的服务器,客户要想连我的网,就必须发送给我MAC地址,那么我对此MAC地址进行计时,只允许使用3分钟,再进行计次,每隔N小时只能使用3次,那么站在程序员的角度来说, 客户是无论怎样试图篡改网络协议中的参数,也是没办法突破小米路由器的限制,来达到单MAC地址无限使用网络的.毕竟功能在服务器上面,逆向破解软件的我对此深有体会… 那么这样就没有必要再继续研究下去了,我发现整个流程中唯一我能攻击的漏洞就在于每个用户能体验三分钟网络本身. 我下载了一个TMAC(修改MAC地址),结合自动联网程序(易语言简单迅速),不到一会就开发出了一个简易的暴力联网程序. 该程序每隔一段时间随机修改MAC地址,然后访问联网API进行联网,总之我暂时是能舒服地用这个带宽10MB的网络了(打游戏还是有点勉强….) ","date":"2018-11-17","objectID":"/posts/%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E5%B0%8F%E8%AE%B0/:0:0","tags":["实习"],"title":"获取网络小记","uri":"/posts/%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E5%B0%8F%E8%AE%B0/"},{"categories":null,"content":"fjqisba，毕业于南京邮电大学软件工程系。 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"作者信息","uri":"/about/"}]